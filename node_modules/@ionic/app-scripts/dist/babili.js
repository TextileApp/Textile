"use strict";
var path_1 = require('path');
var cross_spawn_1 = require('cross-spawn');
var config_1 = require('./util/config');
var logger_1 = require('./logger/logger');
var helpers_1 = require('./util/helpers');
function babili(context, configFile) {
    configFile = config_1.getUserConfigFile(context, exports.taskInfo, configFile);
    var logger = new logger_1.Logger('babili - experimental');
    return babiliWorker(context, configFile).then(function () {
        logger.finish();
    })
        .catch(function (err) {
        throw logger.fail(err);
    });
}
exports.babili = babili;
function babiliWorker(context, configFile) {
    var babiliConfig = config_1.fillConfigDefaults(configFile, exports.taskInfo.defaultConfigFile);
    // TODO - figure out source maps??
    return runBabili(context, babiliConfig).then(function (minifiedCode) {
        // write the file back to disk
        var fileToWrite = path_1.join(context.buildDir, babiliConfig.destFileName);
        return helpers_1.writeFileAsync(fileToWrite, minifiedCode);
    });
}
exports.babiliWorker = babiliWorker;
function runBabili(context, config) {
    var babiliPath = path_1.join(context.rootDir, 'node_modules', '.bin', 'babili');
    var bundlePath = path_1.join(context.buildDir, config.sourceFile);
    return runBabiliImpl(babiliPath, bundlePath);
}
function runBabiliImpl(pathToBabili, pathToBundle) {
    // TODO - is there a better way to run this?
    var chunks = [];
    return new Promise(function (resolve, reject) {
        var command = cross_spawn_1.spawn(pathToBabili, [pathToBundle]);
        command.stdout.on('data', function (buffer) {
            var stringRepresentation = buffer.toString();
            logger_1.Logger.debug("[Babili] " + stringRepresentation);
            chunks.push(stringRepresentation);
        });
        command.stderr.on('data', function (buffer) {
            logger_1.Logger.warn("[Babili] " + buffer.toString());
        });
        command.on('close', function (code) {
            if (code !== 0) {
                return reject(new Error('Babili failed with a non-zero status code'));
            }
            return resolve(chunks.join(''));
        });
    });
}
exports.taskInfo = {
    fullArg: '--babili',
    shortArg: null,
    envVar: 'IONIC_EXP_BABILI',
    packageConfig: 'ionic_exp_babili',
    defaultConfigFile: 'babili.config'
};
