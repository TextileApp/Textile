{"version":3,"sources":["../../src/hacks/watch-rewrites.js"],"names":["watchRewrites","self","query","find","undefined","order","limit","constructor","IMPLICIT_LIMIT","Object","assign"],"mappings":";;;kBAawBA,a;AAbxB;;;;;;;;;;;;;AAae,SAASA,aAAT,CAAuBC,IAAvB,EAA6BC,KAA7B,EAAoC;AACjD;AACA;AACA,MAAIA,MAAMC,IAAN,KAAeC,SAAf,IACAF,MAAMG,KAAN,KAAgBD,SADhB,IAEAF,MAAMI,KAAN,KAAgBF,SAFpB,EAE+B;AAC7B,QAAME,QAAQL,KAAKM,WAAL,CAAiBC,cAAjB,IAAmC,MAAjD;AACA;AACA,WAAOC,OAAOC,MAAP,CAAc,EAAEJ,YAAF,EAAd,EAAyBJ,KAAzB,CAAP;AACD,GAND,MAMO;AACL,WAAOA,KAAP;AACD;AACF","file":"watch-rewrites.js","sourcesContent":["/*\n Some common queries run on an entire collection or on a collection of\n indeterminate size. RethinkDB doesn't actually keep track of the\n ordering of these queries when sending changes. The initial changes\n will be ordered, but subsequent changes come in arbitrary order and\n don't respect the ordering of the query. So, for convenience, we add\n a very high limit so that the server will keep track of the order for\n us.\n\n Note: queries like collection.order(field).watch are not reasonable\n in production systems. You should add an explicit limit.\n*/\n\nexport default function watchRewrites(self, query) {\n  // The only query type at the moment that doesn't get these rewrites\n  // is find, since it returns a single document\n  if (query.find === undefined &&\n      query.order !== undefined &&\n      query.limit === undefined) {\n    const limit = self.constructor.IMPLICIT_LIMIT || 100000\n    // Need to copy the object, since it could be reused\n    return Object.assign({ limit }, query)\n  } else {\n    return query\n  }\n}\n"]}