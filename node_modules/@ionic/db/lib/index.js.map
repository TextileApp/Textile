{"version":3,"sources":["../src/index.js"],"names":["IonicDB","host","secure","path","lazyWrites","app_id","undefined","authType","keepalive","retry","WebSocketCtor","WebSocket","tokenStorage","setAuthFromQueryParams","url","socket","handshakeMaker","handshake","bind","subscribe","next","set","token","error","err","test","message","console","remove","collection","name","sendRequest","_digest","currentUser","disconnect","connect","onError","status","do","onDisconnected","filter","x","type","onConnected","onSocketError","onReconnecting","utensils","Object","freeze","_authMethods","_root","_thisPath","hasAuthToken","setToken","removeToken","aggregate","model","options","normalizedType","hzRequest","takeWhile","resp","state","Socket","clearAuthTokens"],"mappings":";;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AACA;;AACA;;AACA;;;;IAEaA,O,WAAAA,O,GAEX,mBAUQ;AAAA;;AAAA,iFAAJ,EAAI;AAAA,uBATNC,IASM;AAAA,MATNA,IASM,6BATC,cASD;AAAA,yBARNC,MAQM;AAAA,MARNA,MAQM,+BARG,IAQH;AAAA,uBAPNC,IAOM;AAAA,MAPNA,IAOM,6BAPC,SAOD;AAAA,6BANNC,UAMM;AAAA,MANNA,UAMM,mCANO,KAMP;AAAA,yBALNC,MAKM;AAAA,MALNA,MAKM,+BALGC,SAKH;AAAA,2BAJNC,QAIM;AAAA,MAJNA,QAIM,iCAJK,iBAIL;AAAA,4BAHNC,SAGM;AAAA,MAHNA,SAGM,kCAHM,EAGN;AAAA,wBAFNC,KAEM;AAAA,MAFNA,KAEM,8BAFE,CAEF;AAAA,gCADNC,aACM;AAAA,MADNA,aACM,sCADUC,SACV;;AAAA;;;AAEN,MAAIN,MAAJ,EAAY;AACVF,WAAOA,OAAO,GAAP,GAAcE,MAArB;AACD;AACD,MAAIE,aAAa,eAAjB,EAAkC;AAChCA,eAAW,OAAX;AACD,GAFD,MAEO;AACLA,eAAW,iBAAX;AACD;;AAED,MAAMK,eAAe,uBAAiB,EAAEL,kBAAF,EAAYJ,UAAZ,EAAjB,CAArB;AACAS,eAAaC,sBAAb;;AAEA,MAAMC,cAAWZ,SAAS,GAAT,GAAe,EAA1B,YAAoCD,IAApC,SAA6CE,IAAnD;AACA,MAAMY,SAAS,0BAAkB;AAC/BD,YAD+B;AAE/BE,oBAAgBJ,aAAaK,SAAb,CAAuBC,IAAvB,CAA4BN,YAA5B,CAFe;AAG/BJ,wBAH+B;AAI/BC,gBAJ+B;AAK/BC;AAL+B,GAAlB,CAAf;;AAQA;AACA;AACAK,SAAOE,SAAP,CAAiBE,SAAjB,CAA2B;AACzBC,QADyB,gBACpBH,SADoB,EACT;AACd,UAAIV,aAAa,iBAAjB,EAAoC;AAClCK,qBAAaS,GAAb,CAAiBJ,UAAUK,KAA3B;AACD;AACF,KALwB;AAMzBC,SANyB,iBAMnBC,GANmB,EAMd;AACT,UAAI,sCAAsCC,IAAtC,CAA2CD,IAAIE,OAA/C,CAAJ,EAA6D;AAC3DC,gBAAQJ,KAAR,CAAc,mDAAd;AACAX,qBAAagB,MAAb;AACD;AACF;AAXwB,GAA3B;;AAcA;AACA;AACA;;AAEA,OAAKC,UAAL,GAAkB,UAACC,IAAD,EAAU;AAC1B,WAAO,oBAAeC,WAAf,EAA4BD,IAA5B,EAAkC1B,UAAlC,EAA8C,MAAK4B,OAAnD,CAAP;AACD,GAFD;;AAIA,OAAKC,WAAL,GAAmB;AAAA,WACjB,6BAAuBlB,OAAOE,SAA9B,EAAyCF,MAAzC,CADiB;AAAA,GAAnB;;AAGA,OAAKmB,UAAL,GAAkB,YAAM;AACtBnB,WAAOmB,UAAP;AACD,GAFD;;AAIA;AACA;AACA;AACA;AACA,OAAKC,OAAL,GAAe,YAEV;AAAA,QADHC,OACG,uEADO,eAAO;AAAET,cAAQJ,KAAR,yBAAoCC,GAApC;AAA4C,KAC5D;;AACHT,WAAOI,SAAP,CACE,YAAM,CAAE,CADV,EAEEiB,OAFF;AAID,GAPD;;AASA;AACA;AACA,OAAKC,MAAL,GAAc;AAAA,WAAMtB,OAAOsB,MAAP,CAAcC,EAAd,CAAiB,MAAKN,OAAtB,CAAN;AAAA,GAAd;;AAEA;AACA,OAAKO,cAAL,GAAsB;AAAA,WAAM,MAAKF,MAAL,GAAcG,MAAd,CAAqB;AAAA,aAAKC,EAAEC,IAAF,KAAW,cAAhB;AAAA,KAArB,CAAN;AAAA,GAAtB;;AAEA;AACA,OAAKC,WAAL,GAAmB;AAAA,WAAM,MAAKN,MAAL,GAAcG,MAAd,CAAqB;AAAA,aAAKC,EAAEC,IAAF,KAAW,WAAhB;AAAA,KAArB,CAAN;AAAA,GAAnB;;AAEA;AACA,OAAKE,aAAL,GAAqB;AAAA,WAAM,MAAKP,MAAL,GAAcG,MAAd,CAAqB;AAAA,aAAKC,EAAEC,IAAF,KAAW,OAAhB;AAAA,KAArB,CAAN;AAAA,GAArB;;AAEA;AACA,OAAKG,cAAL,GAAsB;AAAA,WAAM,MAAKR,MAAL,GAAcG,MAAd,CAAqB;AAAA,aAAKC,EAAEC,IAAF,KAAW,cAAhB;AAAA,KAArB,CAAN;AAAA,GAAtB;;AAEA,OAAKI,QAAL,GAAgB;AACdf,4BADc;AAEdnB,8BAFc;AAGdK,eAAWF,OAAOE;AAHJ,GAAhB;AAKA8B,SAAOC,MAAP,CAAc,KAAKF,QAAnB;;AAEA,OAAKG,YAAL,GAAoB,IAApB;AACA,OAAKC,KAAL,aAAqBhD,MAAD,GAAW,GAAX,GAAiB,EAArC,YAA6CD,IAA7C;AACA,OAAKkD,SAAL,GAAoB,KAAKD,KAAzB,SAAkC/C,IAAlC;AACA,OAAKiD,YAAL,GAAoBxC,aAAawC,YAAb,CAA0BlC,IAA1B,CAA+BN,YAA/B,CAApB;AACA,OAAKyC,QAAL,GAAgBzC,aAAaS,GAAb,CAAiBH,IAAjB,CAAsBN,YAAtB,CAAhB;AACA,OAAK0C,WAAL,GAAmB1C,aAAagB,MAAb,CAAoBV,IAApB,CAAyBN,YAAzB,CAAnB;AACA,OAAK2C,SAAL;AACA,OAAKC,KAAL;;AAGA;AACA;AACA,WAASzB,WAAT,CAAqBW,IAArB,EAA2Be,OAA3B,EAAoC;AAClC;AACA,QAAMC,iBAAiBhB,SAAS,WAAT,GAAuB,QAAvB,GAAkCA,IAAzD;AACA,WAAO3B,OACJ4C,SADI,CACM,EAAEjB,MAAMgB,cAAR,EAAwBD,gBAAxB,EADN,EACyC;AADzC,KAEJG,SAFI,CAEM;AAAA,aAAQC,KAAKC,KAAL,KAAe,UAAvB;AAAA,KAFN,CAAP;AAGD;AAEF,C;;AAGH9D,QAAQ+D,MAAR;AACA/D,QAAQgE,eAAR","file":"index.js","sourcesContent":["import 'rxjs/add/observable/of'\nimport 'rxjs/add/observable/from'\nimport 'rxjs/add/operator/catch'\nimport 'rxjs/add/operator/concatMap'\nimport 'rxjs/add/operator/map'\nimport 'rxjs/add/operator/filter'\nimport 'rxjs/add/operator/do'\n\nimport { Collection, UserDataTerm } from './ast'\nimport { IonicDBSocket } from './socket'\nimport { TokenStorage, clearAuthTokens } from './auth'\nimport { aggregate, model } from './model'\n\nexport class IonicDB {\n  \n  constructor({\n    host = 'api.ionic.io',\n    secure = true,\n    path = 'ionicdb',\n    lazyWrites = false,\n    app_id = undefined,\n    authType = 'unauthenticated',\n    keepalive = 50, // ELB defaults to 60 so this should keep us alive\n    retry = 5, // Default retry timeout to 5 seconds\n    WebSocketCtor = WebSocket,\n  } = {}) {\n\n    if (app_id) {\n      path = path + '/' +  app_id;\n    }\n    if (authType === 'authenticated') {\n      authType = 'token';\n    } else {\n      authType = 'unauthenticated'\n    }\n\n    const tokenStorage = new TokenStorage({ authType, path })\n    tokenStorage.setAuthFromQueryParams()\n\n    const url = `ws${secure ? 's' : ''}:\\/\\/${host}\\/${path}`\n    const socket = new IonicDBSocket({\n      url,\n      handshakeMaker: tokenStorage.handshake.bind(tokenStorage),\n      keepalive,\n      retry,\n      WebSocketCtor,\n    })\n\n    // Store whatever token we get back from the server when we get a\n    // handshake response\n    socket.handshake.subscribe({\n      next(handshake) {\n        if (authType !== 'unauthenticated') {\n          tokenStorage.set(handshake.token)\n        }\n      },\n      error(err) {\n        if (/JsonWebTokenError|TokenExpiredError/.test(err.message)) {\n          console.error('IonicDB: clearing token storage since auth failed')\n          tokenStorage.remove()\n        }\n      },\n    })\n\n    // This is the object returned by the IonicDB function. It's a\n    // function so we can construct a collection simply by calling it\n    // like this.collection('my_collection')\n\n    this.collection = (name) => {\n      return new Collection(sendRequest, name, lazyWrites, this._digest)\n    }\n\n    this.currentUser = () =>\n      new UserDataTerm(this, socket.handshake, socket)\n\n    this.disconnect = () => {\n      socket.disconnect()\n    }\n\n    // Dummy subscription to force it to connect to the\n    // server. Optionally provide an error handling function if the\n    // socket experiences an error.\n    // Note: Users of the Observable interface shouldn't need this\n    this.connect = (\n      onError = err => { console.error(`Received an error: ${err}`) }\n    ) => {\n      socket.subscribe(\n        () => {},\n        onError\n      )\n    }\n\n    // Either subscribe to status updates, or return an observable with\n    // the current status and all subsequent status changes.\n    this.status = () => socket.status.do(this._digest)\n\n    // Convenience method for finding out when disconnected\n    this.onDisconnected = () => this.status().filter(x => x.type === 'disconnected')\n\n    // Convenience method for finding out when ready\n    this.onConnected = () => this.status().filter(x => x.type === 'connected')\n\n    // Convenience method for finding out when an error occurs\n    this.onSocketError = () => this.status().filter(x => x.type === 'error')\n\n    // Convenience method for finding out when ready\n    this.onReconnecting = () => this.status().filter(x => x.type === 'reconnecting')\n\n    this.utensils = {\n      sendRequest,\n      tokenStorage,\n      handshake: socket.handshake,\n    }\n    Object.freeze(this.utensils)\n\n    this._authMethods = null\n    this._root = `http${(secure) ? 's' : ''}://${host}`\n    this._thisPath = `${this._root}/${path}`\n    this.hasAuthToken = tokenStorage.hasAuthToken.bind(tokenStorage)\n    this.setToken = tokenStorage.set.bind(tokenStorage)\n    this.removeToken = tokenStorage.remove.bind(tokenStorage)\n    this.aggregate = aggregate\n    this.model = model\n\n\n    // Sends a this protocol request to the server, and pulls the data\n    // portion of the response out.\n    function sendRequest(type, options) {\n      // Both remove and removeAll use the type 'remove' in the protocol\n      const normalizedType = type === 'removeAll' ? 'remove' : type\n      return socket\n        .hzRequest({ type: normalizedType, options }) // send the raw request\n        .takeWhile(resp => resp.state !== 'complete')\n    }\n\n  }\n}\n\nIonicDB.Socket = IonicDBSocket\nIonicDB.clearAuthTokens = clearAuthTokens\n"]}