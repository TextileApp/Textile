{"version":3,"sources":["../src/model.js"],"names":["aggregate","model","checkWatchArgs","args","length","Error","isTerm","term","fetch","watch","isPromise","then","isObservable","subscribe","lift","isPrimitive","value","undefined","indexOf","Date","ArrayBuffer","PrimitiveTerm","_value","toString","of","watchArgs","ObservableTerm","from","ArrayTerm","map","x","_reducer","_query","operation","join","empty","qs","forkJoin","combineLatest","AggregateTerm","Object","keys","k","pairs","reduce","prev","s","spec","Array","isArray","constructor"],"mappings":"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","file":"model.js","sourcesContent":["import { Observable } from 'rxjs/Observable'\n\nimport 'rxjs/add/observable/of'\nimport 'rxjs/add/observable/forkJoin'\nimport 'rxjs/add/observable/combineLatest'\nimport 'rxjs/add/operator/map'\n\n// Other imports\nimport isPlainObject from 'is-plain-object'\n\n// Unlike normal queries' .watch(), we don't support rawChanges: true\n// for aggregates\nfunction checkWatchArgs(args) {\n  if (args.length > 0) {\n    throw new Error(\".watch() on aggregates doesn't support arguments!\")\n  }\n}\n\nfunction isTerm(term) {\n  return typeof term.fetch === 'function' &&\n         typeof term.watch === 'function'\n}\n\nfunction isPromise(term) {\n  return typeof term.then === 'function'\n}\n\nfunction isObservable(term) {\n  return typeof term.subscribe === 'function' &&\n         typeof term.lift === 'function'\n}\n\n// Whether an object is primitive. We consider functions\n// non-primitives, lump Dates and ArrayBuffers into primitives.\nfunction isPrimitive(value) {\n  if (value === null) {\n    return true\n  }\n  if (value === undefined) {\n    return false\n  }\n  if (typeof value === 'function') {\n    return false\n  }\n  if ([ 'boolean', 'number', 'string' ].indexOf(typeof value) !== -1) {\n    return true\n  }\n  if (value instanceof Date || value instanceof ArrayBuffer) {\n    return true\n  }\n  return false\n}\n\n// Simple wrapper for primitives. Just emits the primitive\nclass PrimitiveTerm {\n  constructor(value) {\n    this._value = value\n  }\n\n  toString() {\n    return this._value.toString()\n  }\n\n  fetch() {\n    return Observable.of(this._value)\n  }\n\n  watch(...watchArgs) {\n    checkWatchArgs(watchArgs)\n    return Observable.of(this._value)\n  }\n}\n\n// Simple wrapper for observables to normalize the\n// interface. Everything in an aggregate tree should be one of these\n// term-likes\nclass ObservableTerm {\n  constructor(value) {\n    this._value = value\n  }\n\n  toString() {\n    return this._value.toString()\n  }\n\n  fetch() {\n    return Observable.from(this._value)\n  }\n\n  watch(...watchArgs) {\n    checkWatchArgs(watchArgs)\n    return Observable.from(this._value)\n  }\n}\n\n// Handles aggregate syntax like [ query1, query2 ]\nclass ArrayTerm {\n  constructor(value) {\n    // Ensure this._value is an array of Term\n    this._value = value.map(x => aggregate(x))\n  }\n\n  _reducer(...args) {\n    return args\n  }\n\n  _query(operation) {\n    return this._value.map(x => x[operation]())\n  }\n\n  toString() {\n    return `[ ${this._query('toString').join(', ')} ]`\n  }\n\n  fetch() {\n    if (this._value.length === 0) {\n      return Observable.empty()\n    }\n\n    const qs = this._query('fetch')\n    return Observable.forkJoin(...qs, this._reducer)\n  }\n\n  watch(...watchArgs) {\n    checkWatchArgs(watchArgs)\n\n    if (this._value.length === 0) {\n      return Observable.empty()\n    }\n\n    const qs = this._query('watch')\n    return Observable.combineLatest(...qs, this._reducer)\n  }\n}\n\nclass AggregateTerm {\n  constructor(value) {\n    // Ensure this._value is an array of [ key, Term ] pairs\n    this._value = Object.keys(value).map(k => [ k, aggregate(value[k]) ])\n  }\n\n  _reducer(...pairs) {\n    return pairs.reduce((prev, [ k, x ]) => {\n      prev[k] = x\n      return prev\n    }, {})\n  }\n\n  _query(operation) {\n    return this._value.map(\n      ([ k, term ]) => term[operation]().map(x => [ k, x ]))\n  }\n\n  toString() {\n    const s = this._value.map(([ k, term ]) => `'${k}': ${term}`)\n    return `{ ${s.join(', ')} }`\n  }\n\n  fetch() {\n    if (this._value.length === 0) {\n      return Observable.of({})\n    }\n\n    const qs = this._query('fetch')\n    return Observable.forkJoin(...qs, this._reducer)\n  }\n\n  watch(...watchArgs) {\n    checkWatchArgs(watchArgs)\n\n    if (this._value.length === 0) {\n      return Observable.of({})\n    }\n\n    const qs = this._query('watch')\n    return Observable.combineLatest(...qs, this._reducer)\n  }\n}\n\nexport function aggregate(spec) {\n  if (isTerm(spec)) {\n    return spec\n  }\n  if (isObservable(spec) || isPromise(spec)) {\n    return new ObservableTerm(spec)\n  }\n  if (isPrimitive(spec)) {\n    return new PrimitiveTerm(spec)\n  }\n  if (Array.isArray(spec)) {\n    return new ArrayTerm(spec)\n  }\n  if (isPlainObject(spec)) {\n    return new AggregateTerm(spec)\n  }\n\n  throw new Error(`Can't make an aggregate with ${spec} in it`)\n}\n\nexport function model(constructor) {\n  return (...args) => aggregate(constructor(...args))\n}\n"]}