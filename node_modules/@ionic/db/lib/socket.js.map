{"version":3,"sources":["../src/socket.js"],"names":["tryCatch","errorObject","e","undefined","tryCatchTarget","tryCatcher","t","apply","arguments","fn","PROTOCOL_VERSION","STATUS_UNCONNECTED","type","STATUS_CONNECTED","STATUS_ERROR","STATUS_DISCONNECTED","STATUS_RECONNECTING","ProtocolError","msg","errorCode","toString","message","Error","IonicDBSocket","resultSelector","JSON","parse","data","next","value","request","stringify","url","handshakeMaker","keepalive","retry","WebSocketCtor","WebSocket","protocol","openObserver","sendHandshake","closeObserver","code","reason","console","error","_autoreconnect","status","handshake","_reconnecting","setTimeout","_handshakeSub","unsubscribe","_handshakeMaker","timer","map","hzRequest","subscribe","publish","requestCounter","activeRequests","Map","activeSubscriptions","_output","disconnect","values","sub","complete","multiplex","subMsg","unsubMsg","messageFilter","state","observer","result","method","first","x","subscription","deactivateRequest","req","delete","request_id","activateRequest","set","filterRequest","resp","getRequest","Object","assign","oldHandshakeSub","isReconnect","makeRequest","n","error_code","add","connect","rawRequest","_sub_query","switchMap","ignoreElements","concat","concatMap","push","share"],"mappings":"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","file":"socket.js","sourcesContent":["import { AsyncSubject } from 'rxjs/AsyncSubject'\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject'\nimport { WebSocketSubject } from 'rxjs/observable/dom/WebSocketSubject'\nimport { Observable } from 'rxjs/Observable'\nimport { Subscription } from 'rxjs/Subscription'\nimport 'rxjs/add/observable/merge'\nimport 'rxjs/add/observable/timer'\nimport 'rxjs/add/operator/filter'\nimport 'rxjs/add/operator/first'\nimport 'rxjs/add/operator/share'\nimport 'rxjs/add/operator/ignoreElements'\nimport 'rxjs/add/operator/concat'\nimport 'rxjs/add/operator/takeWhile'\nimport 'rxjs/add/operator/publish'\nimport 'rxjs/add/operator/switchMap'\n\nimport { serialize, deserialize } from './serialization.js'\n\nlet errorObject = { e: undefined };\n\nlet tryCatchTarget;\n\nfunction tryCatcher(t) {\n  try {\n    return tryCatchTarget.apply(t, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch(fn) {\n  tryCatchTarget = fn;\n  return tryCatcher;\n};\n\nconst PROTOCOL_VERSION = 'ionicdb-v0'\n\n// Before connecting the first time\nconst STATUS_UNCONNECTED = { type: 'unconnected' }\n// After the websocket is opened and handshake is completed\nconst STATUS_CONNECTED = { type: 'connected' }\n// After unconnected, maybe before or after connected. Any socket level error\nconst STATUS_ERROR = { type: 'error' }\n// Occurs when the socket closes\nconst STATUS_DISCONNECTED = { type: 'disconnected' }\n// Occurs when attempting to reconnect\nconst STATUS_RECONNECTING = { type: 'reconnecting' }\n\nclass ProtocolError extends Error {\n  constructor(msg, errorCode) {\n    super(msg)\n    this.errorCode = errorCode\n  }\n  toString() {\n    return `${this.message} (Code: ${this.errorCode})`\n  }\n}\n\n\n// Wraps native websockets with a Subject, which is both an Subscriber\n// and an Observable (it is bi-directional after all!). This version\n// is based on the rxjs.observable.dom.WebSocketSubject implementation.\nexport class IonicDBSocket extends WebSocketSubject {\n  // Deserializes a message from a string. Overrides the version\n  // implemented in WebSocketSubject\n  resultSelector(e) {\n    return deserialize(JSON.parse(e.data))\n  }\n\n  // We're overriding the next defined in AnonymousSubject so we\n  // always serialize the value. When this is called a message will be\n  // sent over the socket to the server.\n  next(value) {\n    const request = JSON.stringify(serialize(value))\n    super.next(request)\n  }\n\n  constructor({\n    url,              // Full url to connect to\n    handshakeMaker, // function that returns handshake to emit\n    keepalive = 60,   // seconds between keepalive messages\n    retry = 5, // seconds to wait before attempting reconnect\n    WebSocketCtor = WebSocket,    // optionally provide a WebSocket constructor\n  } = {}) {\n    super({\n      url,\n      protocol: PROTOCOL_VERSION,\n      WebSocketCtor,\n      openObserver: {\n        next: () => this.sendHandshake(),\n      },\n      closeObserver: {\n        next: (e) => {\n          // If we didn't close cleanly we should reconnect\n          // else we close up shop\n          if (e.code !== 1000) {\n            let reason = e.reason || `Unexpected disconnect with error code ${e.code}.`;\n            console.error(\"Connection Failed: \", reason);\n            if (this._autoreconnect) {\n              console.error(\"Retrying in \" + retry + \" seconds.\");\n              this.status.next(STATUS_RECONNECTING)\n              this.handshake = new AsyncSubject()\n              this._reconnecting = true;\n              setTimeout( () => {\n                if (this._autoreconnect) {\n                  this.sendHandshake();\n                } else {\n                  this.status.next(STATUS_DISCONNECTED)\n                  if (this._handshakeSub) {\n                    this._handshakeSub.unsubscribe()\n                    this._handshakeSub = null\n                  }\n                }\n              }, retry * 1000)\n            } else {\n                this.status.next(STATUS_DISCONNECTED)\n                if (this._handshakeSub) {\n                  this._handshakeSub.unsubscribe()\n                  this._handshakeSub = null\n                }\n            }\n          } else { \n            this.status.next(STATUS_DISCONNECTED)\n            if (this._handshakeSub) {\n              this._handshakeSub.unsubscribe()\n              this._handshakeSub = null\n            }\n          }\n        },\n      },\n    })\n    // Completes or errors based on handshake success. Buffers\n    // handshake response for later subscribers (like a Promise)\n    this.handshake = new AsyncSubject()\n    this._handshakeMaker = handshakeMaker\n    this._handshakeSub = null\n    this._reconnecting = false;\n    this._autoreconnect = true;\n\n    this.keepalive = Observable\n      .timer(keepalive * 1000, keepalive * 1000)\n      .map(n => this.hzRequest({ type: 'keepalive' }).subscribe())\n      .publish()\n\n    // This is used to emit status changes that others can hook into.\n    this.status = new BehaviorSubject(STATUS_UNCONNECTED)\n    // Keep track of subscribers so we's can decide when to\n    // unsubscribe.\n    this.requestCounter = 0\n    // A map from request_ids to an object with metadata about the\n    // request. Eventually, this should allow re-sending requests when\n    // reconnecting.\n    this.activeRequests = new Map()\n    this.activeSubscriptions = new Map()\n    this._output.subscribe({\n      // This emits if the entire socket errors (usually due to\n      // failure to connect)\n      error: () => {\n        this.status.next(STATUS_ERROR);\n      },\n    })\n  }\n\n  disconnect() {\n    this._autoreconnect = false;\n    for(let sub of this.activeSubscriptions.values()){\n      sub.complete();\n    }\n    this.complete();\n    if (this._handshakeSub) {\n      this._handshakeSub.unsubscribe()\n      this._handshakeSub = null\n    }\n  }\n\n  multiplex(subMsg, unsubMsg, messageFilter, state) {\n    return new Observable((observer) => {\n      // If we are reconnecting let everyone\n      // down the line know so that they know\n      // the changefeed is going to rebuild and\n      // can respond appropriately\n      if (state === STATUS_RECONNECTING) {\n        observer.next({state: state.type});\n      }\n\n      const result = tryCatch(subMsg)();\n      if (result === errorObject) {\n        observer.error(errorObject.e);\n      } else {\n        if (result.method) {\n          this.next(result);\n        } else {\n          this.status.first( x => x === STATUS_CONNECTED).subscribe( () => this.next(result));\n        }\n      }\n\n      let subscription = this.subscribe(x => {\n        const result = tryCatch(messageFilter)(x);\n        if (result === errorObject) {\n          observer.error(errorObject.e);\n        } else if (result) {\n          if(state.type === \"keepalive\" && x.state === \"complete\"){\n            observer.complete();\n          } else {\n            observer.next(x);\n          }\n        }\n      },\n        err => {\n          // We need to eat errors here so that reconnect works\n          // and the observers don't unsubscribe themselves\n          // if the entire socket errors\n        },\n        () => observer.complete());\n\n      return () => {\n        const result = tryCatch(unsubMsg)();\n        if (result === errorObject) {\n          observer.error(errorObject.e);\n        } else {\n          this.next(result);\n        }\n        subscription.unsubscribe();\n      };\n    });\n  }\n\n  deactivateRequest(req) {\n    return () => {\n      this.activeRequests.delete(req.request_id)\n      this.activeSubscriptions.delete(req.request_id);\n      return { request_id: req.request_id, type: 'end_subscription' }\n    }\n  }\n\n  activateRequest(req) {\n    return () => {\n      this.activeRequests.set(req.request_id, req)\n      return req\n    }\n  }\n\n  filterRequest(req) {\n    return resp => resp.request_id === req.request_id\n  }\n\n  getRequest(request) {\n    return Object.assign({ request_id: this.requestCounter++ }, request)\n  }\n\n  // This is a trimmed-down version of multiplex that only listens for\n  // the handshake requestId. It also starts the keepalive observable\n  // and cleans up after it when the handshake is cleaned up.\n  sendHandshake() {\n    if (!this._handshakeSub || this._reconnecting) {\n      let oldHandshakeSub = this._handshakeSub;\n      let isReconnect = this._reconnecting;\n      this._reconnecting = false;\n      this._handshakeSub = this.makeRequest(this._handshakeMaker())\n        .subscribe({\n          next: n => {\n            if (n.error) {\n              this.status.next(STATUS_ERROR)\n              this.handshake.error(new ProtocolError(n.error, n.error_code))\n            } else {\n              this.status.next(STATUS_CONNECTED)\n              this._autoreconnect = true; // Renable autoreconnect\n              if (isReconnect) {\n                for(let sub of this.activeSubscriptions.values()){\n                  sub.next(STATUS_RECONNECTING);\n                }\n              }\n              this.handshake.next(n)\n              this.handshake.complete()\n            }\n          },\n          error: e => {\n            this.status.next(STATUS_ERROR)\n            this.handshake.error(e)\n          },\n        })\n\n      // Start the keepalive and make sure it's\n      // killed when the handshake is cleaned up\n      this._handshakeSub.add(this.keepalive.connect())\n        \n      // clean up in the case of reconnect\n      if (oldHandshakeSub) {\n        oldHandshakeSub.unsubscribe();\n      }\n    }\n    return this.handshake\n  }\n\n  // Incorporates shared logic between the inital handshake request and\n  // all subsequent requests.\n  // * Generates a request id and filters by it\n  // * Send `end_subscription` when observable is unsubscribed\n  makeRequest(rawRequest) {\n    const request = this.getRequest(rawRequest)\n\n    if(request.type === 'subscribe'){\n      return this._sub_query(request);\n    }else {\n      return this.multiplex(\n        this.activateRequest(request),\n        this.deactivateRequest(request),\n        this.filterRequest(request),\n        request\n      );\n    }\n  }\n\n  // Creates a subscription query that can survive reconnects\n  _sub_query(request){\n    let sub = new BehaviorSubject(STATUS_CONNECTED);\n    this.activeSubscriptions.set(request.request_id, sub);\n\n    return sub.switchMap( state => {\n      return this.multiplex(\n        this.activateRequest(request),\n        this.deactivateRequest(request),\n        this.filterRequest(request),\n        state\n      )\n    });\n  }\n\n  // Wrapper around the makeRequest with the following additional\n  // features we need for horizon's protocol:\n  // * Sends handshake on subscription if it hasn't happened already\n  // * Wait for the handshake to complete before sending the request\n  // * Errors when a document with an `error` field is received\n  // * Completes when `state: complete` is received\n  // * Emits `state: synced` as a separate document for easy filtering\n  // * Reference counts subscriptions\n  hzRequest(rawRequest) {\n    return this.sendHandshake().ignoreElements()\n      .concat(this.makeRequest(rawRequest))\n      .concatMap(resp => {\n        if (resp.error !== undefined) {\n          throw new ProtocolError(resp.error, resp.error_code)\n        }\n        const data = resp.data || []\n\n        if (resp.state !== undefined) {\n          // Create a little dummy object for sync notifications\n          data.push({\n            type: 'state',\n            state: resp.state,\n          })\n        }\n\n        return data\n      })\n      .share()\n  }\n}\n"]}