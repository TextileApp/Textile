{
  "_args": [
    [
      {
        "raw": "body@^5.1.0",
        "scope": null,
        "escapedName": "body",
        "name": "body",
        "rawSpec": "^5.1.0",
        "spec": ">=5.1.0 <6.0.0",
        "type": "range"
      },
      "/Users/Matthew/Textile/node_modules/tiny-lr"
    ]
  ],
  "_from": "body@>=5.1.0 <6.0.0",
  "_id": "body@5.1.0",
  "_inCache": true,
  "_location": "/body",
  "_nodeVersion": "0.10.32",
  "_npmUser": {
    "name": "raynos",
    "email": "raynos2@gmail.com"
  },
  "_npmVersion": "2.7.4",
  "_phantomChildren": {},
  "_requested": {
    "raw": "body@^5.1.0",
    "scope": null,
    "escapedName": "body",
    "name": "body",
    "rawSpec": "^5.1.0",
    "spec": ">=5.1.0 <6.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/tiny-lr"
  ],
  "_resolved": "https://registry.npmjs.org/body/-/body-5.1.0.tgz",
  "_shasum": "e4ba0ce410a46936323367609ecb4e6553125069",
  "_shrinkwrap": null,
  "_spec": "body@^5.1.0",
  "_where": "/Users/Matthew/Textile/node_modules/tiny-lr",
  "author": {
    "name": "Raynos",
    "email": "raynos2@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/Raynos/body/issues",
    "email": "raynos2@gmail.com"
  },
  "contributors": [
    {
      "name": "Jake Verbaten"
    }
  ],
  "dependencies": {
    "continuable-cache": "^0.3.1",
    "error": "^7.0.0",
    "raw-body": "~1.1.0",
    "safe-json-parse": "~1.0.1"
  },
  "description": "Body parsing",
  "devDependencies": {
    "after": "~0.7.0",
    "hammock": "^1.0.0",
    "process": "~0.5.1",
    "send-data": "~1.0.1",
    "tape": "~2.3.0",
    "test-server": "~0.1.3"
  },
  "directories": {},
  "dist": {
    "shasum": "e4ba0ce410a46936323367609ecb4e6553125069",
    "tarball": "https://registry.npmjs.org/body/-/body-5.1.0.tgz"
  },
  "gitHead": "d0f0d98a923b8690d694dcc4272b5ce998470d6e",
  "homepage": "https://github.com/Raynos/body",
  "keywords": [],
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/Raynos/body/raw/master/LICENSE"
    }
  ],
  "main": "index",
  "maintainers": [
    {
      "name": "raynos",
      "email": "raynos2@gmail.com"
    }
  ],
  "name": "body",
  "optionalDependencies": {},
  "readme": "# body [![build status][1]][2]\n\nBody parsing\n\nOriginally taken from [npm-www](https://github.com/isaacs/npm-www)\n\n## Example\n\n```js\nvar textBody = require(\"body\")\nvar jsonBody = require(\"body/json\")\nvar formBody = require(\"body/form\")\nvar anyBody = require(\"body/any\")\nvar http = require(\"http\")\nvar sendJson = require(\"send-data/json\")\n\nhttp.createServer(function handleRequest(req, res) {\n    function send(err, body) {\n        sendJson(req, res, body)\n    }\n\n    if (req.url === \"/body\") {\n        // all functions can be called with (req, cb)\n        textBody(req, send)\n    } else if (req.url === \"/form\") {\n        // all functions can be called with (req, opts, cb)\n        formBody(req, {}, send)\n    } else if (req.url === \"/json\") {\n        // all functions can be called with (req, res, cb)\n        jsonBody(req, res, send)\n    } else if (req.url === \"/any\") {\n        // all functions can be called with (req, res, opts, cb)\n        anyBody(req, res, {}, send)\n    }\n})\n```\n\n`body` simply parses the request body and returns it in the callback. `jsonBody` and `formBody` call JSON.parse and querystring.parse respectively on the body.\n\nanyBody will detect the content-type of the request and use the appropiate body method.\n\n## Example generators\n\nYou can use `body` with generators as the body functions will\n    return a continuable if you don't pass a callback.\n\n```js\nvar http = require(\"http\")\nvar Router = require(\"routes-router\")\nvar jsonBody = require(\"body/json\")\nvar formBody = require(\"body/form\")\n// async turns a generator into an async function taking a cb\nvar async = require(\"gens\")\n\n// the router works with normal async functions.\n// router automatically handles errors as 500 responses\nvar app = Router({\n    // do whatever you want. the jsonBody error would go here\n    errorHandler: function (req, res, err) {\n        res.statusCode = 500\n        res.end(err.message)\n    }\n})\n\napp.addRoute(\"/json\", async(function* (req, res) {\n    // if jsonBody has an error it just goes to the cb\n    // in the called in the router. and it does the correct thing\n    // it shows your 500 page.\n    var body = yield jsonBody(req, res)\n\n    res.setHeader(\"content-type\", \"application/json\")\n    res.end(JSON.stringify(body))\n}))\n\napp.addRoute(\"/form\", async(function* (req, res) {\n    var body = yield formBody(req, res)\n\n    res.setHeader(\"content-type\", \"application/json\")\n    res.end(JSON.stringify(body))\n}))\n\n// app returned from the router is just a function(req, res) {}\n// that dispatches the req/res to the correct route based on\n// the routers routing table & req.url\nhttp.createServer(app).listen(8080)\n```\n\n## Documentation\n\n### `textBody(req, res?, opts?, cb<Error, String>)`\n\n```ocaml\ntextBody := (\n    req: HttpRequest,\n    res?: HttpResponse,\n    opts?: {\n        limit?: Number,\n        cache?: Boolean,\n        encoding?: String\n    },\n    cb: Callback<err: Error, bodyPayload: String>\n) => void\n```\n\n`textBody` allows you to get the body from any readable stream.\nIt will read the entire content of the stream into memory and\ngive it back to you in the callback.\n\n - `limit`: You can set `opts.limit` to a custom number to change the \n    limit at which `textBody` gives up. By default it will only\n    read a 1MB body, if a stream contains more then 1MB it returns\n    an error. This prevents someone attacking your HTTP server\n    with an infinite body causing an out of memory attack.\n - `encoding`: You can set `encoding`. All encodings that are valid on a \n    [`Buffer`](http://nodejs.org/api/buffer.html#buffer_buffer) are\n    valid options. It defaults to `'utf8'`\n\n```js\nvar textBody = require(\"body\")\nvar http = require(\"http\")\n\nhttp.createServer(function (req, res) {\n    textBody(req, res, function (err, body) {\n        // err probably means invalid HTTP protocol or some shiz.\n        if (err) {\n            res.statusCode = 500\n            return res.end(\"NO U\")\n        }\n\n        // I am an echo server\n        res.end(body)\n    })\n}).listen(8080)\n```\n\n### `formBody(req, res?, opts?, cb<Error, Any>)`\n\n```ocaml\nformBody := (\n    req: HttpRequest,\n    res?: HttpResponse,\n    opts?: {\n        limit?: Number,\n        encoding?: String,\n        querystring: {\n            parse: (String, Callback<Error, Any>) => void\n        }\n    },\n    cb: Callback<err: Error, bodyPayload: Any>\n) => void\n```\n\n`formBody` allows you to get the body of a readable stream. It\ndoes the same as `textBody` but assumes the content is querystring\nencoded and parses just like it was a &lt;form&gt; submit.\n\n - `limit`: same as `textBody`\n - `encoding`: same as `textBody`\n - `querystring`: You can pass a custom querystring parser if \n    you want. It should have a `parse` method that takes a \n    string and a callback. It should return the value in the\n    callback or a parsing error\n\n```js\nvar formBody = require(\"body/form\")\nvar http = require(\"http\")\n\nhttp.createServer(function (req, res) {\n    formBody(req, res, function (err, body) {\n        // err probably means invalid HTTP protocol or some shiz.\n        if (err) {\n            res.statusCode = 500\n            return res.end(\"NO U\")\n        }\n\n        // I am an echo server\n        res.setHeader(\"content-type\", \"application/json\")\n        res.end(JSON.stringify(body))\n    })\n}).listen(8080)\n```\n\n### `jsonBody(req, res?, opts?, cb<Error, Any>)`\n\n```ocaml\njsonBody := (\n    req: HttpRequest,\n    res?: HttpResponse,\n    opts?: {\n        limit?: Number,\n        encoding?: String,\n        reviver?: (Any) => Any\n        JSON?: {\n            parse: (String, reviver?: Function, Callback<Error, Any>) => void\n        }\n    },\n    cb: Callback<err: Error, bodyPayload: Any>\n) => void\n```\n\n`jsonBody` allows you to get the body of a readable stream. It\ndoes the same as `textbody` but assumes the content it a JSON\nvalue and parses it using `JSON.parse`. If `JSON.parse` throws\nan exception then it calls the callback with the exception.\n\n - `limit`: same as `textBody`\n - `encoding`: same as `textBody`\n - `reviver`: A reviver function that will be passed to `JSON.parse`\n    as the second argument\n - `JSON`: You can pass a custom JSON parser if you want.\n    It should have a `parse` method that takes a string, an\n    optional reviver and a callback. It should return the value\n    in the callback or a parsing error.\n\n```js\nvar jsonBody = require(\"body/json\")\nvar http = require(\"http\")\n\nhttp.createServer(function (req, res) {\n    jsonBody(req, res, function (err, body) {\n        // err is probably an invalid json error\n        if (err) {\n            res.statusCode = 500\n            return res.end(\"NO U\")\n        }\n\n        // I am an echo server\n        res.setHeader(\"content-type\", \"application/json\")\n        res.end(JSON.stringify(body))\n    })\n}).listen(8080)\n```\n\n### `anyBody(req, res?, opts?, cb<Error, Any>)`\n\n```ocaml\nanyBody := (\n    req: HttpRequest,\n    res?: HttpResponse,\n    opts?: {\n        limit?: Number,\n        encoding?: String,\n        reviver?: (Any) => Any\n        JSON?: {\n            parse: (String, reviver?: Function, Callback<Error, Any>) => void\n        },\n        querystring: {\n            parse: (String, Callback<Error, Any>) => void\n        }\n    },\n    cb: Callback<err: Error, bodyPayload: Any>\n) => void\n```\n\n`anyBody` allows you to get the body of a HTTPRequest. It \ndoes the same as `textBody` except it parses the `content-type`\nheader and uses either the jsonBody or the formBody function.\n\nThis allows you to write POST route handlers that work with\nboth ajax and html form submits.\n\n - `limit`: same as `textBody`\n - `encoding`: same as `textBody`\n - `reviver`: same as `jsonBody`\n - `JSON`: same as `jsonBody`\n - `querystring`: same as `formBody`\n\n```js\nvar anyBody = require(\"body/any\")\nvar http = require(\"http\")\n\nhttp.createServer(function (req, res) {\n    anyBody(req, res, function (err, body) {\n        // err is probably an invalid json error\n        if (err) {\n            res.statusCode = 500\n            return res.end(\"NO U\")\n        }\n\n        // I am an echo server\n        res.setHeader(\"content-type\", \"application/json\")\n        res.end(JSON.stringify(body))\n    })\n}).listen(8080)\n```\n\n\n## Installation\n\n`npm install body`\n\n## Tests\n\n`npm test`\n\n## Contributors\n\n - Raynos\n\n## MIT Licenced\n\n  [1]: https://secure.travis-ci.org/Raynos/body.png\n  [2]: http://travis-ci.org/Raynos/body\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/Raynos/body.git"
  },
  "scripts": {
    "test": "node ./test/index.js"
  },
  "version": "5.1.0"
}
